package org.example;

import de.offis.mosaik.api.SimProcess;
import de.offis.mosaik.api.Simulator;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;

import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.Logger;


//    todo: this smart meter has to use docker top to lookup cpu levels of the task sim inside the container?? not sure of this actually
// todo: it has to run outside of docker. the idea is that it could be plugged into any black box container

/*
This means we need a “layer” between Mosaik and the Docker container, which takes care of the message passing.
No application within the container should implement any Mosaik API, only the “layer”, which has two jobs:
    - It communicates the containers power consumption to Mosaik (which is what we originally meant by “smart meter”).
      Meaning on every get_data() [1] call, it outputs a ‘P_out’ variable, similar to the households in the mosaik demo.
      The value is generated by inspecting the containers CPU usage and applying the power model, as we discussed in the last meeting. todo: ask about power model
      This output will be connected to a pypower node in Mosaik, again equivalently as in the demo.
    - It communicates information from the simulation (such as the current solar power generation, battery state, etc.) to the application in the container.
      So this is the information the layer receives from the simulation on every step() [2]
 */

public class ControlNode extends Simulator {
    private static final Logger logger = Logger.getLogger(ControlNode.class.getName());

    private static final JSONObject META = (JSONObject) JSONValue.parse(("{"
            + "    'api_version': " + Simulator.API_VERSION + ","
            + "    'type': 'time-based',"
            + "    'models': {"
            + "        'ControlNode': {"
            + "            'public': true,"
            + "            'params': [],"
            + "            'attrs': ['aggregate_power', 'battery_power', 'pv_power', 'grid_power', 'edge_node_need']"
            + "        }"
            + "    }"
            + "}").replace("'", "\""));

    final Map<Long, Map<String, Object>> stepsInfo;

    private Long stepCount = 0L;

    public static DateTimeFormatter DATE_TIME_FORMATTER;

    private static String ENTITY_ID;

    private double gridPower;
    private double pvPower;
    private double batteryPower;
    private double edgeNodeNeed;
    private double aggregatePower;

    public ControlNode(String simName) {
        super(simName);

        LogManager.getLogManager().addLogger(logger);
        logger.setLevel(Level.FINE);

        this.stepsInfo = new HashMap<>();
        DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");

        logger.info("org.example.ControlNode constructed");
    }

    public static void main(String[] args) throws Exception {
        logger.info("org.example.ControlNode main started ... ");

//        testCpuLimit();

        runSimulation(args);

        logger.info("org.example.ControlNode main finished");
    }

    private static void runSimulation(String[] args) throws Exception {
        Simulator sim = new ControlNode("ControlNode");
        if (args.length < 1) {
            String[] ipaddr = {"127.0.0.1:8000"};
            SimProcess.startSimulation(ipaddr, sim);
        } else {
            logger.info("args: " + Arrays.toString(args));
            SimProcess.startSimulation(args, sim);
        }
    }

    @Override
    public Map<String, Object> init(String sid, Float timeResolution, Map<String, Object> simParams) throws Exception {
        logger.info("init called ");

        if (simParams.containsKey("eid"))
            ENTITY_ID = simParams.get("eid").toString();

        return META;
    }

    @Override
    public List<Map<String, Object>> create(int num, String model, Map<String, Object> modelParams) throws Exception {
        logger.info("create called ");
        if (num != 1)
            throw new RuntimeException("Value of param 'num' in create method = [" + num + "], expected 1. System design only allows for one entity per simulation.");

        JSONArray entities = new JSONArray();

        JSONObject entity = new JSONObject();
        entity.put("eid", ENTITY_ID);
        entity.put("type", model);
        entity.put("rel", new JSONArray());

        entities.add(entity);
        return entities;
    }

    @Override
    public long step(long time, Map<String, Object> inputs, long maxAdvance) throws Exception {
        logger.info("step called ");

        // todo (medium): for loop below is not needed? extract gridPower value directly? -- rn it is needed bcs we have another attr (pvPower)
        for (Map.Entry<String, Object> entity : inputs.entrySet()) {
            Map<String, Object> attributes = (Map<String, Object>) entity.getValue();
            for (Map.Entry<String, Object> attr : attributes.entrySet()) {
                if (attr.getKey().equals("grid_power")) // todo: grid_power needed?
                    handleGridPowerValue(((Number) ((JSONObject) attr.getValue()).values().toArray()[0]).doubleValue());
                if (attr.getKey().equals("pv_power"))
                    handlePvPowerValue(((Number) ((JSONObject) attr.getValue()).values().toArray()[0]).doubleValue());
                if (attr.getKey().equals("battery_power"))
                    handleBatteryPowerValue(((Number) ((JSONObject) attr.getValue()).values().toArray()[0]).doubleValue());
                if (attr.getKey().equals("edge_node_need"))
                    handleEdgeNodeNeedValue(((Number) ((JSONObject) attr.getValue()).values().toArray()[0]).doubleValue());
            }
        }
        // todo (low): is this needed? SIMULATOR.step() -- rn it saves each step's info but the info is not used
        updateStepInfo();

        return time + 900; // every 15 mins, todo: change?
    }


    @Override
    public Map<String, Object> getData(Map<String, List<String>> outputs) throws Exception {
        logger.info("getData called ");

        Map<String, Object> data = new HashMap<>();

        for (Map.Entry<String, List<String>> entity : outputs.entrySet()) {
            if (!ENTITY_ID.equals(entity.getKey()))
                throw new RuntimeException("wrong entity id received [" + entity.getKey() + "], expected [" + ENTITY_ID + "].");
            Map<String, Object> values = new HashMap<>();
            for (String attr : entity.getValue()) {
                switch (attr) {
                    case "P_out":
                        values.put(attr, 500); // todo: get cpu power need from node
                        logger.info("P_out = " + values.get(attr));
                        break;
                    case "aggregate_power":
                        values.put(attr, this.aggregatePower);
                        logger.info("aggregate_power = " + values.get(attr));
                        break;
                    default:
                        logger.warning("unexpected attr requested [" + attr + "]");
                        throw new RuntimeException("unexpected attr requested [" + attr + "]");
                }
            }
            data.put(ENTITY_ID, values);
        }
        return data;
    }

    private void handlePvPowerValue(double pvPower) {
        // todo (high): consider using pv_power to directly get how much power the PV is producing instead of using grid_power which we get from the grid node. Advantages vs Disadvantages?
        // todo (high): and accordingly maybe use pv_power to change cpu level limitation instead of grid_power
        logger.info("+++ pvPower = [" + pvPower + "]");

        this.pvPower = pvPower;
    }

    private void handleGridPowerValue(double gridPower) {
        logger.info("+++ gridPower = [" + gridPower + "]");

        this.gridPower = gridPower;

        CpuUtils.handleCpuLevel(gridPower); // todo: philipp said apply a power model here. what does it mean? do we still limit cpu
    }

    private void handleBatteryPowerValue(double batteryPower) {
        logger.info("+++ batterPower = [" + batteryPower + "]");

        this.batteryPower = batteryPower;
    }

    private void handleEdgeNodeNeedValue(double edgeNodeNeed) {
        logger.info("+++ edgeNodeNeed = [" + edgeNodeNeed + "]");

        this.edgeNodeNeed = edgeNodeNeed;
    }

    public void updateStepInfo() {
        this.stepsInfo.put(++this.stepCount, new HashMap<>());
        this.stepsInfo.get(this.stepCount).put("gridPower", this.gridPower);
        this.stepsInfo.get(this.stepCount).put("pvPower", this.pvPower);
        this.stepsInfo.get(this.stepCount).put("batteryPower", this.batteryPower);
        this.stepsInfo.get(this.stepCount).put("edgeNodeNeed", this.edgeNodeNeed);

        this.aggregatePower = this.batteryPower + this.pvPower + this.gridPower - this.edgeNodeNeed;
        this.stepsInfo.get(this.stepCount).put("aggregatePower", this.aggregatePower);

    }

    private static void testCpuLimit() {
        try {
            CpuUtils.startCpuLimitProcess();
            CpuUtils.updateCpuLimitProcessId();

            logger.info("going to sleep for 10000 BEFORE killing cpulimit process");

            Thread.sleep(10000);
            logger.info("waking up");

            logger.info("killing cpulimit process");
            if (CpuUtils.CPU_LIMIT_PID_LIST.size() > 0) {
                // kill running cpulimit process, and nullify CPU_LIMIT_PID
                CpuUtils.killCpuLimitProcess();
            }

            logger.info("going to sleep for 10000 AFTER killing cpulimit process");
            Thread.sleep(10000);

            CpuUtils.startCpuLimitProcess();
            CpuUtils.updateCpuLimitProcessId();

            logger.info("CPU_LIMIT_PID_List = " + CpuUtils.CPU_LIMIT_PID_LIST.toString());
            logger.info("TASK_SIM_PID = " + CpuUtils.TASK_SIM_PID);

            logger.info("going to sleep for 10000 BEFORE killing cpulimit process the 2nd time");
            Thread.sleep(10000);
            if (CpuUtils.CPU_LIMIT_PID_LIST.size() > 0) {
                // kill running cpulimit process, and nullify CPU_LIMIT_PID
                CpuUtils.killCpuLimitProcess();
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
