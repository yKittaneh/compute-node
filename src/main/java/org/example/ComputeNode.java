package org.example;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import de.offis.mosaik.api.SimProcess;
import de.offis.mosaik.api.Simulator;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.client.BufferingClientHttpRequestFactory;
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.Logger;

import static java.lang.Math.abs;

/*
This means we need a “layer” between Mosaik and the Docker container, which takes care of the message passing.
No application within the container should implement any Mosaik API, only the “layer”, which has two jobs:
    - It communicates the containers power consumption to Mosaik (which is what we originally meant by “smart meter”).
      Meaning on every get_data() [1] call, it outputs a ‘P_out’ variable, similar to the households in the mosaik demo.
      The value is generated by inspecting the containers CPU usage and applying the power model, as we discussed in the last meeting. todo: ask about power model
      This output will be connected to a pypower node in Mosaik, again equivalently as in the demo.
    - It communicates information from the simulation (such as the current solar power generation, battery state, etc.) to the application in the container.
      So this is the information the layer receives from the simulation on every step() [2]
 */

public class ComputeNode extends Simulator {
    private static final Logger logger = Logger.getLogger(ComputeNode.class.getName());

    private static final JSONObject META = (JSONObject) JSONValue.parse(("{"
            + "    'api_version': " + Simulator.API_VERSION + ","
            + "    'type': 'time-based',"
            + "    'models': {"
            + "        'ComputeNode': {"
            + "            'public': true,"
            + "            'params': [],"
            + "            'attrs': ['aggregate_power', 'battery_power', 'pv_power', 'grid_power', 'container_need']"
            + "        }"
            + "    }"
            + "}").replace("'", "\""));

    final Map<Long, Map<String, Object>> stepsInfo;

    private Long stepCount = 0L;

    public static DateTimeFormatter DATE_TIME_FORMATTER;

    private static String ENTITY_ID;

    private double gridPower;
    private double pvPower;
    private double batteryPower;
    private double containerNeed;
    private double aggregatePower;

    private static RestTemplate restTemplate;

    private static String restServiceUrl;

    public ComputeNode(String simName, String restUrl) {
        super(simName);

        LogManager.getLogManager().addLogger(logger);
        logger.setLevel(Level.FINE);

        this.stepsInfo = new HashMap<>();
        DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");

        restServiceUrl = restUrl;
        ClientHttpRequestFactory factory = new BufferingClientHttpRequestFactory(new SimpleClientHttpRequestFactory());
        restTemplate = new RestTemplate(factory);

        logger.info("org.example.ControlNode constructed");
    }

    public static void main(String[] args) throws Exception {
        logger.info("org.example.ControlNode main started ... ");

//        testRestServer();

//        testCpuLimit();

        runSimulation(args);

        logger.info("org.example.ControlNode main finished");
    }

    private static void runSimulation(String[] args) throws Exception {
        Simulator sim = new ComputeNode("ControlNode", "http://localhost:5567");
        if (args.length < 1) {
            String[] ipaddr = {"127.0.0.1:8000"};
            SimProcess.startSimulation(ipaddr, sim);
        } else {
            logger.info("args: " + Arrays.toString(args));
            SimProcess.startSimulation(args, sim);
        }
    }

    @Override
    public Map<String, Object> init(String sid, Float timeResolution, Map<String, Object> simParams) throws Exception {
        logger.info("init called ");

        if (simParams.containsKey("eid"))
            ENTITY_ID = simParams.get("eid").toString();

        return META;
    }

    @Override
    public List<Map<String, Object>> create(int num, String model, Map<String, Object> modelParams) throws Exception {
        logger.info("create called ");
        if (num != 1)
            throw new RuntimeException("Value of param 'num' in create method = [" + num + "], expected 1. System design only allows for one entity per simulation.");

        JSONArray entities = new JSONArray();

        JSONObject entity = new JSONObject();
        entity.put("eid", ENTITY_ID);
        entity.put("type", model);
        entity.put("rel", new JSONArray());

        entities.add(entity);
        return entities;
    }

    @Override
    public long step(long time, Map<String, Object> inputs, long maxAdvance) throws Exception {
        logger.info("step called ");

        for (Map.Entry<String, Object> entity : inputs.entrySet()) {
            Map<String, Object> attributes = (Map<String, Object>) entity.getValue();
            for (Map.Entry<String, Object> attr : attributes.entrySet()) {
//                if (attr.getKey().equals("grid_power")) // todo: grid_power needed?
//                    handleGridPowerValue(((Number) ((JSONObject) attr.getValue()).values().toArray()[0]).doubleValue());
                if (attr.getKey().equals("pv_power"))
                    handlePvPowerValue(((Number) ((JSONObject) attr.getValue()).values().toArray()[0]).doubleValue());
                if (attr.getKey().equals("battery_power"))
                    handleBatteryPowerValue(((Number) ((JSONObject) attr.getValue()).values().toArray()[0]).doubleValue());
            }
        }

        this.aggregatePower = this.batteryPower + this.pvPower;

        // todo (low): is this needed? -- rn it saves each step's info but the info is not used. Use for evaluation?
        updateStepInfo();

        pushInfoToContainer();

        return time + 900; // every 15 mins, todo: change returned time?
    }

    @Override
    public Map<String, Object> getData(Map<String, List<String>> outputs) throws Exception {
        logger.info("getData called ");

        Map<String, Object> data = new HashMap<>();

        for (Map.Entry<String, List<String>> entity : outputs.entrySet()) {
            if (!ENTITY_ID.equals(entity.getKey()))
                throw new RuntimeException("wrong entity id received [" + entity.getKey() + "], expected [" + ENTITY_ID + "].");
            Map<String, Object> values = new HashMap<>();
            for (String attr : entity.getValue()) {
                switch (attr) {
                    case "container_need":
                        // todo: we get value from container's cpu level, need to apply a power model. What? How?
                        values.put(attr, CpuUtils.getTaskCpuLevel() * 15);
                        logger.info("container_need = " + values.get(attr));
                        break;
                    case "aggregate_power":
                        values.put(attr, this.aggregatePower);
                        logger.info("aggregate_power = " + values.get(attr));
                        break;
                    default:
                        logger.warning("unexpected attr requested [" + attr + "]");
                        throw new RuntimeException("unexpected attr requested [" + attr + "]");
                }
            }

            data.put(ENTITY_ID, values);
        }
        return data;
    }

    private void pushInfoToContainer() {
        logger.info("pushing input map to container");

        logger.info("sending rest request to " + restServiceUrl + "/stepInformation");

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        ObjectMapper objectMapper = new ObjectMapper();

        Map<String, Double> infoMap = new HashMap<>();
        infoMap.put("pv_power", this.pvPower);
        infoMap.put("battery_power", this.batteryPower);

        try {
            String json = objectMapper.writeValueAsString(infoMap);
            HttpEntity<String> request = new HttpEntity<>(json, headers);
            ResponseEntity<String> response = restTemplate.postForEntity(restServiceUrl + "/stepInformation", request, String.class);

            logger.info("response: " + response);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
    }

    private void handlePvPowerValue(double pvPower) {
        this.pvPower = abs(pvPower);
        logger.info("+++ pvPower = [" + this.pvPower + "]");
    }

    private void handleGridPowerValue(double gridPower) {
        this.gridPower = abs(gridPower);

        logger.info("+++ gridPower = [" + this.gridPower + "]");

        CpuUtils.handleCpuLevel(this.gridPower); // todo: philipp said apply a power model here. what does it mean? do we still limit cpu
    }

    private void handleBatteryPowerValue(double batteryPower) {
        this.batteryPower = abs(batteryPower);
        logger.info("+++ batterPower = [" + this.batteryPower + "]");
    }

    private void handleContainerNeedValue(double containerNeed) {
        logger.info("+++ containerNeed = [" + containerNeed + "]");

        this.containerNeed = containerNeed;
    }

    public void updateStepInfo() {
        this.stepsInfo.put(++this.stepCount, new HashMap<>());
        this.stepsInfo.get(this.stepCount).put("pvPower", this.pvPower);
        this.stepsInfo.get(this.stepCount).put("batteryPower", this.batteryPower);
        this.stepsInfo.get(this.stepCount).put("containerNeed", this.containerNeed);
//        this.stepsInfo.get(this.stepCount).put("aggregatePower", this.aggregatePower);
//        this.stepsInfo.get(this.stepCount).put("gridPower", this.gridPower);
    }

    private static void testRestServer() {
        logger.info("started testRestServer");

        ComputeNode node = new ComputeNode("testRestServer", "http://localhost:5567");

        logger.info("sending rest request to " + restServiceUrl + "/");
        ResponseEntity<String> response = restTemplate.getForEntity(restServiceUrl + "/", String.class);

        logger.info("response: " + response);

        node.pvPower = 987.6D;
        node.batteryPower = 2005.7D;

        node.pushInfoToContainer();

        logger.info("finished testRestServer");
    }

    private static void testCpuLimit() {
        try {
            CpuUtils.startCpuLimitProcess();
            CpuUtils.updateCpuLimitProcessId();

            logger.info("going to sleep for 10000 BEFORE killing cpulimit process");

            Thread.sleep(10000);
            logger.info("waking up");

            logger.info("killing cpulimit process");
            if (CpuUtils.CPU_LIMIT_PID_LIST.size() > 0) {
                // kill running cpulimit process, and nullify CPU_LIMIT_PID
                CpuUtils.killCpuLimitProcess();
            }

            logger.info("going to sleep for 10000 AFTER killing cpulimit process");
            Thread.sleep(10000);

            CpuUtils.startCpuLimitProcess();
            CpuUtils.updateCpuLimitProcessId();

            logger.info("CPU_LIMIT_PID_List = " + CpuUtils.CPU_LIMIT_PID_LIST.toString());
            logger.info("TASK_SIM_PID = " + CpuUtils.TASK_SIM_PID);

            logger.info("going to sleep for 10000 BEFORE killing cpulimit process the 2nd time");
            Thread.sleep(10000);
            if (CpuUtils.CPU_LIMIT_PID_LIST.size() > 0) {
                // kill running cpulimit process, and nullify CPU_LIMIT_PID
                CpuUtils.killCpuLimitProcess();
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
